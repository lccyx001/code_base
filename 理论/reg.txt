不怕念起 就怕觉迟 理可顿悟 事须渐修
http://www.cnblogs.com/lincappu/p/8143866.html
********************************************
正则表达式


特殊字符:
$ 正则匹配的结尾
()标记一个子表达式的开始和结束的位置,选择作用
* 匹配多次或零次
+ 匹配多次或一次
. 匹配任何单字符   如 [.] 只会匹配 .字符，等价于 \.，而非匹配除换行符 \n 外的所有字符。
[ 标记一个中括号表达式的开始
？匹配前面的字表达式零次或一次
^ 匹配输入字符串的开始位置，在[]中表示逻辑非  ^ 指的是匹配字符串开始的位置 [^指定字符串] 指的是除指定字符串以外的其他字符串
例如：
(^[0-9])+     //匹配有一至多个数字的字符串组合
[^[0-9]]+  // 匹配有一至多个不含数字的字符串组合

{ 标记限定符表达式的开始


限定符:指定正则表达式的一个给定组件必须要出现多少次才能满足匹配。有 * 或 + 或 ? 或 {n} 或 {n,} 或 {n,m} 
* 
{n} n为非负整数，匹配确定的n次
{n,} n非负整数,至少匹配n次
{n,m} n<=m 至少n次，至多m次

实例：

/Chapter [1-9][0-9]*/ 匹配编号为任何位数的章节标题


<H1>Chapter 1 - 介绍正则表达式</H1>
/<.*>/ 匹配从开始小于符号 (<) 到关闭 H1 标记的大于符号 (>) 之间的所有内容。

/<.*?>/ 匹配开始和结束 H1 标签，下面的非贪婪表达式只匹配 <H1>。

运算符的优先级:
first level:\ 
second level:(), (?:), (?=), []
third level:*, +, ?, {n}, {n,}, {n,m}
forth level:^, $, \任何元字符、任何字符
fifth level:|

不常见：

(?=pattern)：正向肯定预查（look ahead positive assert），在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，"Windows(?=95|98|NT|2000)"能匹配"Windows2000"中的"Windows"，但不能匹配"Windows3.1"中的"Windows"。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。

(?!pattern)：正向否定排查

(?<=pattern):反向否定排查 反向(look behind)肯定预查，与正向肯定预查类似，只是方向相反。例如，"(?<=95|98|NT|2000)Windows"能匹配"2000Windows"中的"Windows"，但不能匹配"3.1Windows"中的"Windows"。

容易混淆：
() 表示分组，意思就是括号内是一个整体。
[] 表示范围，匹配其中任何一个     
{} 表示重复匹配多次。

匹配模式：
/i  不区分大小写 insensitive
/g 全局匹配 global
/m 多行模式 multi
/gi 和/ig  就是/i 和/g的组合

常用
\1 ：正则表达式中的小括号"()"。是代表分组的意思。 如果再其后面出现\1则是代表与第一个小括号中要匹配的内容相同。
\d :数字
\w :字母数字下划线


